import{readJSON as E,saveJSON as J}from"boma";import T from"@gratio/crypt";import R from"path";import{appendDataToConfig as x,formatConfigToString as M,formatObjectToConfigSection as W,genNewClientKeys as $,getClientEncryptionPass as b,getCurrentEndpoint as G,getFrontendConfig as v,getInterfacePeersIPs as H,getIfaceParams as h,getFirstAvailableIP as _,loadServerConfig as I,removePeerFromConfig as q,resolveWireguardPath as z}from"../utils/index.js";import{PEERS_PATH as j}from"../utils/constants.js";import{decryptSecret as K,encryptSecret as C}from"../utils/crypto.js";const S=T.serverCrypt.encryptMsg,P=()=>E({filePath:R.resolve(j),parseJSON:!0,createIfNotFound:{}}),w=n=>{J({filePath:j,objToSave:JSON.parse(JSON.stringify(n)),format:!0,logSaving:!1})},N=n=>{const{clientIp:s,iface:c,secretKey:o,presharedKey:r,serverPubKey:e,serverPort:t,dns:i}=n,f=G();return M({Interface:{PrivateKey:o,Address:s,DNS:i.join(", ")},Peer:{PresharedKey:r,PublicKey:e,AllowedIPs:"0.0.0.0/0",Endpoint:`${f}:${t}`,PersistentKeepalive:25}})},Y=async(n,s,c)=>{const o=n.body?.ip,r=n.body?.name,e=n.body?.iface;try{const t=h(e);if(!t.success||!t.data){s.status(400).json(t);return}const{cidr:i,pubkey:f,port:l}=t.data,p=H(e);if(typeof o=="string"&&o.trim().length>0&&p.includes(o)){s.status(400).json({success:!1,errors:"Requested IP for new client is already in use"});return}const a=await $(),d=o??_(p,i);if(!d){s.status(409).json({success:!1,errors:"No free IPs left in this interface CIDR"});return}const u=d;await x(z(e),W("Peer",{PublicKey:a.pubKey,PresharedKey:a.presharedKey,AllowedIPs:u}));const y=P(),g=b(),m=new Date().toISOString();y[a.pubKey]={name:r??"",active:!0,ip:u,presharedKey:C(a.presharedKey,g),secretKey:C(a.randomKey,g),iface:e,createdAt:m,updatedAt:m},w(y);const{dns:A,frontendPasskey:O}=v(),k=N({iface:e,clientIp:u,secretKey:a.randomKey,presharedKey:a.presharedKey,serverPubKey:f,serverPort:l,dns:A});await I();const D={client:{pubKey:a.pubKey,name:r??"",ip:u,iface:e},config:k},F=S({message:D,pass:O});s.status(201).json({success:!0,data:F})}catch(t){console.error("addNewClient service error: ",t),s.status(520).json({success:!1,errors:"Can`t add new client"}),c(t)}},Z=async(n,s,c)=>{const o=n.body?.iface,r=n.body?.pubKey;if(!r||typeof r!="string"||r.trim().length!==44){s.status(422).json({success:!1,errors:"Incorrect public key!"});return}try{const e=P();if(!e[r]){s.status(404).json({success:!1,errors:"Peer not found"});return}if(!q(o,r)){s.status(404).json({success:!1,errors:"Peer not found in config"});return}delete e[r],w(e),await I(),s.status(200).json({success:!0})}catch(e){console.error("removeClient service error: ",e),s.status(520).json({success:!1,errors:"Can`t remove client"}),c(e)}},ee=async(n,s,c)=>{const o=n.params.pubKey;try{if(!o){s.status(400).json({success:!1,errors:"Public key is required"});return}const e=P()[o];if(!e||!e.iface){s.status(404).json({success:!1,errors:"Client not found"});return}const t=h(e.iface);if(!t.success||!t.data){s.status(400).json(t);return}const i=b();if(!e.secretKey||!e.presharedKey){s.status(400).json({success:!1,errors:"Client secrets are missing"});return}const f=K(e.secretKey,i),l=K(e.presharedKey,i),{dns:p,frontendPasskey:a}=v(),d=N({iface:e.iface,clientIp:e.ip,secretKey:f,presharedKey:l,serverPubKey:t.data.pubkey,serverPort:t.data.port,dns:p}),u={client:{pubKey:o,name:e.name,ip:e.ip,iface:e.iface},config:d},y=S({message:u,pass:a});s.status(200).json({success:!0,data:y})}catch(r){console.error("getClientConfig service error: ",r),s.status(520).json({success:!1,errors:"Can`t build client config"}),c(r)}};export{Y as addNewClient,ee as getClientConfig,Z as removeClient};
