import{readJSON as E,saveJSON as J}from"boma";import R from"@gratio/crypt";import T from"path";import{appendDataToConfig as x,formatConfigToString as $,formatObjectToConfigSection as M,genNewClientKeys as G,getClientEncryptionPass as b,getCurrentEndpoint as H,getFrontendConfig as v,getInterfacePeersIPs as W,getIfaceParams as h,getFirstAvailableIP as _,loadServerConfig as I,removePeerFromConfig as q}from"../utils/index.js";import{PEERS_PATH as j}from"../utils/constants.js";import{decryptSecret as K,encryptSecret as C}from"../utils/crypto.js";const w=R.serverCrypt.encryptMsg,P=()=>E({filePath:T.resolve(j),parseJSON:!0,createIfNotFound:{}}),S=n=>{J(j,JSON.parse(JSON.stringify(n)),!0)},N=n=>{const{clientIp:s,iface:a,secretKey:o,presharedKey:r,serverPubKey:e,serverPort:t,dns:i}=n,f=H();return $({Interface:{PrivateKey:o,Address:s,DNS:i.join(", ")},Peer:{PresharedKey:r,PublicKey:e,AllowedIPs:"0.0.0.0/0",Endpoint:`${f}:${t}`,PersistentKeepalive:25}})},X=async(n,s,a)=>{const o=n.body?.ip,r=n.body?.name,e=n.body?.iface;try{const t=h(e);if(!t.success||!t.data){s.status(400).json(t);return}const{cidr:i,pubkey:f,port:l}=t.data,p=W(e);if(typeof o=="string"&&o.trim().length>0&&p.includes(o)){s.status(400).json({success:!1,errors:"Requested IP for new client is already in use"});return}const c=await G(),d=o??_(p,i);if(!d){s.status(409).json({success:!1,errors:"No free IPs left in this interface CIDR"});return}const u=d;await x(`/etc/wireguard/${e}.conf`,M("Peer",{PublicKey:c.pubKey,PresharedKey:c.presharedKey,AllowedIPs:u}));const y=P(),g=b(),m=new Date().toISOString();y[c.pubKey]={name:r??"",active:!0,ip:u,presharedKey:C(c.presharedKey,g),secretKey:C(c.randomKey,g),iface:e,createdAt:m,updatedAt:m},S(y);const{dns:A,frontendPasskey:O}=v(),k=N({iface:e,clientIp:u,secretKey:c.randomKey,presharedKey:c.presharedKey,serverPubKey:f,serverPort:l,dns:A});await I();const D={client:{pubKey:c.pubKey,name:r??"",ip:u,iface:e},config:k},F=w({message:D,pass:O});s.status(201).json({success:!0,data:F})}catch(t){console.error("addNewClient service error: ",t),s.status(520).json({success:!1,errors:"Can`t add new client"}),a(t)}},Y=async(n,s,a)=>{const o=n.body?.iface,r=n.body?.pubKey;if(!r||typeof r!="string"||r.trim().length!==44){s.status(422).json({success:!1,errors:"Incorrect public key!"});return}try{const e=P();if(!e[r]){s.status(404).json({success:!1,errors:"Peer not found"});return}if(!q(o,r)){s.status(404).json({success:!1,errors:"Peer not found in config"});return}delete e[r],S(e),await I(),s.status(200).json({success:!0})}catch(e){console.error("removeClient service error: ",e),s.status(520).json({success:!1,errors:"Can`t remove client"}),a(e)}},Z=async(n,s,a)=>{const o=n.params.pubKey;try{if(!o){s.status(400).json({success:!1,errors:"Public key is required"});return}const e=P()[o];if(!e||!e.iface){s.status(404).json({success:!1,errors:"Client not found"});return}const t=h(e.iface);if(!t.success||!t.data){s.status(400).json(t);return}const i=b();if(!e.secretKey||!e.presharedKey){s.status(400).json({success:!1,errors:"Client secrets are missing"});return}const f=K(e.secretKey,i),l=K(e.presharedKey,i),{dns:p,frontendPasskey:c}=v(),d=N({iface:e.iface,clientIp:e.ip,secretKey:f,presharedKey:l,serverPubKey:t.data.pubkey,serverPort:t.data.port,dns:p}),u={client:{pubKey:o,name:e.name,ip:e.ip,iface:e.iface},config:d},y=w({message:u,pass:c});s.status(200).json({success:!0,data:y})}catch(r){console.error("getClientConfig service error: ",r),s.status(520).json({success:!1,errors:"Can`t build client config"}),a(r)}};export{X as addNewClient,Z as getClientConfig,Y as removeClient};
