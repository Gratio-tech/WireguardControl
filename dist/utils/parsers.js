import l from"fs";import{getNameFromSavedData as u,normalizeLineBreaks as g}from"./tools.js";const S=n=>{const t={interface:{},peers:[]},r=n.split(/(?:\s*(interface|peer)\s*:)/gi).filter(e=>e);for(let e=0;e<r.length;e+=2){if(typeof r[e+1]>"u")continue;const s=r[e].trim().toLowerCase(),c=g(r[e+1].trim()).split(/\n/),i={name:""};c.forEach((o,f)=>{f===0?i.name=o:i[o.split(":")[0].trim()]=o.slice(o.indexOf(":")+1).trim()}),s==="peer"?(i["public key"]=i.name,i.name=u(i.name),t.peers.push(i)):t[s]=i}return t},d=n=>{const t={peers:[]};if(typeof n!="string"||!n.length)return t;const r=n.split(/\[(.+?)\]/g);for(let e=1;e<r.length;e+=2){const s=r[e].trim().toLowerCase(),c=g(r[e+1].trim());s==="peer"?t.peers.push(c):t[s]=c}return t},m=n=>{const t=n.trim();if(!t.startsWith("#")&&!t.startsWith(";")){const r=t.match(/^([^=]+)=(.*)$/);if(r){const e=r[1].trim(),s=r[2].trim();return{[e]:s}}}},b=n=>{if(!n||typeof n!="string")throw new Error("Interface must be a string!");const t=`/etc/wireguard/${n}.conf`;if(!l.existsSync(t))throw new Error("Incorrect interface!");console.log(`Try to parse interface ${t}`);try{const r=l.readFileSync(t,"utf8"),e=d(r),s={interface:{},peers:[]};for(const c in e){const i=c.toLowerCase();if(i==="peers"){const o=e[c];Array.isArray(o)&&(s.peers=o.map(f=>{const a={};return f.split(`
`).forEach(h=>{const p=m(h);p&&Object.assign(a,p)}),a.PublicKey&&(a.name=u(a.PublicKey)),a}))}else if(i==="interface"){const o=e[c];typeof o=="string"&&o.split(`
`).forEach(f=>{const a=m(f);a&&(s.interface={...s.interface,...a})})}}return s}catch(r){const e=r;throw new Error(`Failed to parse config file: ${e.message}`)}};export{b as parseInterfaceConfig,S as parseStatus,d as splitBySections};
