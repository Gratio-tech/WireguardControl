import o from"fs";import M from"path";import{readJSON as m,saveJSON as I}from"boma";import{isExistAndNotNull as P}from"vanicom";import{COLORS as f,genPubKey as _,getAllConfigs as K,getServerIP as D,getStatusFromBash as L}from"./index.js";import{parseInterfaceConfig as W}from"./parsers.js";import{CONFIG_EXAMPLE_PATH as w,CONFIG_PATH as c,INTERFACES_PATH as v,PEERS_PATH as y,DEFAULT_RUNTIME_ROTATION_MINUTES as G}from"./constants.js";const C=e=>{const t=M.dirname(e);o.existsSync(t)||o.mkdirSync(t,{recursive:!0}),o.existsSync(e)||o.writeFileSync(e,"{}","utf-8")},H=()=>{if(!o.existsSync(c))if(console.log("config.json not found"),o.existsSync(w))o.copyFileSync(w,c),console.log("config.example.json copied to config.json");else throw console.log(f.Red," "),console.error(`No config files found! Create a config.json file in the project root with the params: {
  "defaultInterface": (string),
  "frontServerPort": (number),
  "allowedOrigins": [string, string],
  "frontendPasskey": (string),
  "dns": [string],
  "clientEncryptionPass": (string)
}`),console.log(f.Reset," "),new Error("Config files not found");const e=m({filePath:c,createIfNotFound:{},parseJSON:!0});if(Array.isArray(e.allowedOrigins)||(e.allowedOrigins=[]),!e.frontendPasskey)throw new Error("frontendPasskey is required in config.json");if(!e.clientEncryptionPass)throw new Error("clientEncryptionPass is required in config.json");return e.dns||(e.dns=["10.8.1.1"]),e},B=e=>Array.isArray(e)?e.map(t=>t.trim()).filter(Boolean):typeof e=="string"?e.split(",").map(t=>t.trim()).filter(Boolean):["10.8.1.1"],ee=async()=>{C(y),C(v);let e=H(),t=m({filePath:y,createIfNotFound:{},parseJSON:!0});const b=m({filePath:v,createIfNotFound:{},parseJSON:!0}),O=Object.keys(b).length,l=await K(),N=await D(),g=await L(),E=B(e.dns),h=e.runtimeRotationMinutes??G,{allowedOrigins:A,defaultInterface:i,frontServerPort:k,frontendPasskey:x,clientEncryptionPass:j}=e,n={allowedOrigins:A,frontServerPort:k,frontendPasskey:x,dns:E,runtimeRotationMinutes:h,clientEncryptionPass:j,wgIsWorking:g.success,configIsOk:!0,endpoint:N,defaultInterface:i||"",interfaces:{}};let u=[];if(l.success&&l.data){for(const r of l.data)try{const{interface:a,peers:F}=await W(r),R=await _(a.PrivateKey),S=[];F.forEach(s=>{s.PublicKey&&(S.push(s.PublicKey),t={...t,[s.PublicKey]:{...t[s.PublicKey],name:t[s.PublicKey]?.name??"",active:!0,ip:s.AllowedIPs,iface:r}})});const p=a.Address.trim().split("/"),T=p.shift(),J=Number(p.length>0?p[0]:"24");n.interfaces[r]={ip:T,cidr:J,port:Number(a.ListenPort),pubkey:R,peers:S},u=[...u,...S],P(i)&&r===i&&(n.defaultInterface=r)}catch(a){console.error(`loadServerConfig fail on parse .conf file ${r}.conf: `,a)}Object.keys(t).forEach(r=>{u.includes(r)||(t[r].active=!1)}),I({filePath:y,objToSave:JSON.parse(JSON.stringify(t)),format:!0,logSaving:!1})}const d=Object.keys(n.interfaces);if(O===0&&!g.success&&(n.configIsOk=!1,console.error("No saved settings are found and WG is off.")),!d.length)n.configIsOk=!1,console.error("No .conf files correctly parsed from /etc/wireguard");else if(!P(i)||!d.includes(i)){const r=d[0];e.defaultInterface=r,I({filePath:c,objToSave:JSON.parse(JSON.stringify(e)),format:!0,logSaving:!1}),console.log("defaultInterface from ./config.json missing or incorrect, set new: ",r),n.defaultInterface=r}n.wgIsWorking=g.success,console.log(`
`,f.Cyan,"Config loaded in memory: ",n,`
`,f.Reset),global.wgControlServerSettings={...n}},U=()=>Object.keys(global.wgControlServerSettings.interfaces||{}),te=()=>global.wgControlServerSettings.defaultInterface,re=()=>({allowedOrigins:global.wgControlServerSettings.allowedOrigins,frontServerPort:global.wgControlServerSettings.frontServerPort,frontendPasskey:global.wgControlServerSettings.frontendPasskey,dns:global.wgControlServerSettings.dns,runtimeRotationMinutes:global.wgControlServerSettings.runtimeRotationMinutes}),ne=()=>global.wgControlServerSettings.clientEncryptionPass,q=e=>{const t=U();return P(e)&&t.includes(String(e))},oe=e=>q(e)?{success:!0,data:{...global.wgControlServerSettings.interfaces[String(e)]}}:{success:!1,errors:"Incorrect interface!"},se=()=>global.wgControlServerSettings.endpoint,ie=e=>{global.wgControlServerSettings.wgIsWorking=e};export{U as getActiveInterfaceses,ne as getClientEncryptionPass,se as getCurrentEndpoint,te as getDefaultInterface,re as getFrontendConfig,oe as getIfaceParams,q as ifaceCorrect,ee as loadServerConfig,ie as setWGStatus};
