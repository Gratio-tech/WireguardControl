import o from"fs";import M from"path";import{readJSON as m,saveJSON as P}from"boma";import{isExistAndNotNull as I}from"vanicom";import{COLORS as f,genPubKey as _,getAllConfigs as K,getServerIP as D,getStatusFromBash as L}from"./index.js";import{parseInterfaceConfig as W}from"./parsers.js";import{CONFIG_EXAMPLE_PATH as w,CONFIG_PATH as a,INTERFACES_PATH as v,PEERS_PATH as y,DEFAULT_RUNTIME_ROTATION_MINUTES as G}from"./constants.js";const C=e=>{const t=M.dirname(e);o.existsSync(t)||o.mkdirSync(t,{recursive:!0}),o.existsSync(e)||o.writeFileSync(e,"{}","utf-8")},H=()=>{if(!o.existsSync(a))if(console.log("config.json not found"),o.existsSync(w))o.copyFileSync(w,a),console.log("config.example.json copied to config.json");else throw console.log(f.Red," "),console.error(`No config files found! Create a config.json file in the project root with the params: {
  "defaultInterface": (string),
  "frontServerPort": (number),
  "allowedOrigins": [string, string],
  "frontendPasskey": (string),
  "dns": [string],
  "clientEncryptionPass": (string)
}`),console.log(f.Reset," "),new Error("Config files not found");const e=m({filePath:a,createIfNotFound:{},parseJSON:!0});if(Array.isArray(e.allowedOrigins)||(e.allowedOrigins=[]),!e.frontendPasskey)throw new Error("frontendPasskey is required in config.json");if(!e.clientEncryptionPass)throw new Error("clientEncryptionPass is required in config.json");return e.dns||(e.dns=["10.8.1.1"]),e},B=e=>Array.isArray(e)?e.map(t=>t.trim()).filter(Boolean):typeof e=="string"?e.split(",").map(t=>t.trim()).filter(Boolean):["10.8.1.1"],ee=async()=>{C(y),C(v);let e=H(),t=m({filePath:y,createIfNotFound:{},parseJSON:!0});const O=m({filePath:v,createIfNotFound:{},parseJSON:!0}),b=Object.keys(O).length,l=await K(),N=await D(),g=await L(),E=B(e.dns),A=e.runtimeRotationMinutes??G,{allowedOrigins:k,defaultInterface:i,frontServerPort:h,frontendPasskey:x,clientEncryptionPass:F}=e,n={allowedOrigins:k,frontServerPort:h,frontendPasskey:x,dns:E,runtimeRotationMinutes:A,clientEncryptionPass:F,wgIsWorking:g.success,configIsOk:!0,endpoint:N,defaultInterface:i||"",interfaces:{}};let u=[];if(l.success&&l.data){for(const r of l.data)try{const{interface:c,peers:R}=await W(r),j=await _(c.PrivateKey),S=[];R.forEach(s=>{s.PublicKey&&(S.push(s.PublicKey),t={...t,[s.PublicKey]:{...t[s.PublicKey],name:t[s.PublicKey]?.name??"",active:!0,ip:s.AllowedIPs,iface:r}})});const p=c.Address.trim().split("/"),T=p.shift(),J=Number(p.length>0?p[0]:"24");n.interfaces[r]={ip:T,cidr:J,port:Number(c.ListenPort),pubkey:j,peers:S},u=[...u,...S],I(i)&&r===i&&(n.defaultInterface=r)}catch(c){console.error(`loadServerConfig fail on parse .conf file ${r}.conf: `,c)}Object.keys(t).forEach(r=>{u.includes(r)||(t[r].active=!1)}),P(y,JSON.parse(JSON.stringify(t)),!0)}const d=Object.keys(n.interfaces);if(b===0&&!g.success&&(n.configIsOk=!1,console.error("No saved settings are found and WG is off.")),!d.length)n.configIsOk=!1,console.error("No .conf files correctly parsed from /etc/wireguard");else if(!I(i)||!d.includes(i)){const r=d[0];e.defaultInterface=r,P(a,JSON.parse(JSON.stringify(e)),!0),console.log("defaultInterface from ./config.json missing or incorrect, set new: ",r),n.defaultInterface=r}n.wgIsWorking=g.success,console.log(`
`,f.Cyan,"Config loaded in memory: ",n,`
`,f.Reset),global.wgControlServerSettings={...n}},U=()=>Object.keys(global.wgControlServerSettings.interfaces||{}),te=()=>global.wgControlServerSettings.defaultInterface,re=()=>({allowedOrigins:global.wgControlServerSettings.allowedOrigins,frontServerPort:global.wgControlServerSettings.frontServerPort,frontendPasskey:global.wgControlServerSettings.frontendPasskey,dns:global.wgControlServerSettings.dns,runtimeRotationMinutes:global.wgControlServerSettings.runtimeRotationMinutes}),ne=()=>global.wgControlServerSettings.clientEncryptionPass,q=e=>{const t=U();return I(e)&&t.includes(String(e))},oe=e=>q(e)?{success:!0,data:{...global.wgControlServerSettings.interfaces[String(e)]}}:{success:!1,errors:"Incorrect interface!"},se=()=>global.wgControlServerSettings.endpoint,ie=e=>{global.wgControlServerSettings.wgIsWorking=e};export{U as getActiveInterfaceses,ne as getClientEncryptionPass,se as getCurrentEndpoint,te as getDefaultInterface,re as getFrontendConfig,oe as getIfaceParams,q as ifaceCorrect,ee as loadServerConfig,ie as setWGStatus};
