import o from"fs";import _ from"path";import{readJSON as m,saveJSON as P}from"boma";import{isExistAndNotNull as I}from"vanicom";import{COLORS as f,genPubKey as M,getAllConfigs as D,getServerIP as K,getStatusFromBash as W}from"./index.js";import{parseInterfaceConfig as G}from"./parsers.js";import{CONFIG_EXAMPLE_PATH as w,CONFIG_PATH as c,INTERFACES_PATH as v,PEERS_PATH as y,DEFAULT_RUNTIME_ROTATION_MINUTES as L,WIREGUARD_DIR as H}from"./constants.js";const C=e=>{const t=_.dirname(e);o.existsSync(t)||o.mkdirSync(t,{recursive:!0}),o.existsSync(e)||o.writeFileSync(e,"{}","utf-8")},U=()=>{if(!o.existsSync(c))if(console.log("config.json not found"),o.existsSync(w))o.copyFileSync(w,c),console.log("config.example.json copied to config.json");else throw console.log(f.Red," "),console.error(`No config files found! Create a config.json file in the project root with the params: {
  "defaultInterface": (string),
  "frontServerPort": (number),
  "allowedOrigins": [string, string],
  "frontendPasskey": (string),
  "dns": [string],
  "clientEncryptionPass": (string)
}`),console.log(f.Reset," "),new Error("Config files not found");const e=m({filePath:c,createIfNotFound:{},parseJSON:!0});if(Array.isArray(e.allowedOrigins)||(e.allowedOrigins=[]),!e.frontendPasskey)throw new Error("frontendPasskey is required in config.json");if(!e.clientEncryptionPass)throw new Error("clientEncryptionPass is required in config.json");return e.dns||(e.dns=["10.8.1.1"]),e},B=e=>Array.isArray(e)?e.map(t=>t.trim()).filter(Boolean):typeof e=="string"?e.split(",").map(t=>t.trim()).filter(Boolean):["10.8.1.1"],te=async()=>{C(y),C(v);let e=U(),t=m({filePath:y,createIfNotFound:{},parseJSON:!0});const b=m({filePath:v,createIfNotFound:{},parseJSON:!0}),O=Object.keys(b).length,l=await D(),N=await K(),g=await W(),E=B(e.dns),A=e.runtimeRotationMinutes??L,{allowedOrigins:h,defaultInterface:i,frontServerPort:k,frontendPasskey:x,clientEncryptionPass:R}=e,n={allowedOrigins:h,frontServerPort:k,frontendPasskey:x,dns:E,runtimeRotationMinutes:A,clientEncryptionPass:R,wgIsWorking:g.success,configIsOk:!0,endpoint:N,defaultInterface:i||"",interfaces:{}};let u=[];if(l.success&&l.data){for(const r of l.data)try{const{interface:a,peers:j}=await G(r),F=await M(a.PrivateKey),S=[];j.forEach(s=>{s.PublicKey&&(S.push(s.PublicKey),t={...t,[s.PublicKey]:{...t[s.PublicKey],name:t[s.PublicKey]?.name??"",active:!0,ip:s.AllowedIPs,iface:r}})});const p=a.Address.trim().split("/"),T=p.shift(),J=Number(p.length>0?p[0]:"24");n.interfaces[r]={ip:T,cidr:J,port:Number(a.ListenPort),pubkey:F,peers:S},u=[...u,...S],I(i)&&r===i&&(n.defaultInterface=r)}catch(a){console.error(`loadServerConfig fail on parse .conf file ${r}.conf: `,a)}Object.keys(t).forEach(r=>{u.includes(r)||(t[r].active=!1)}),P({filePath:y,objToSave:JSON.parse(JSON.stringify(t)),format:!0,logSaving:!1})}const d=Object.keys(n.interfaces);if(O===0&&!g.success&&(n.configIsOk=!1,console.error("No saved settings are found and WG is off.")),!d.length)n.configIsOk=!1,console.error(`No .conf files correctly parsed from ${H}`);else if(!I(i)||!d.includes(i)){const r=d[0];e.defaultInterface=r,P({filePath:c,objToSave:JSON.parse(JSON.stringify(e)),format:!0,logSaving:!1}),console.log("defaultInterface from ./config.json missing or incorrect, set new: ",r),n.defaultInterface=r}n.wgIsWorking=g.success,console.log(`
`,f.Cyan,"Config loaded in memory: ",n,`
`,f.Reset),global.wgControlServerSettings={...n}},q=()=>Object.keys(global.wgControlServerSettings.interfaces||{}),re=()=>global.wgControlServerSettings.defaultInterface,ne=()=>({allowedOrigins:global.wgControlServerSettings.allowedOrigins,frontServerPort:global.wgControlServerSettings.frontServerPort,frontendPasskey:global.wgControlServerSettings.frontendPasskey,dns:global.wgControlServerSettings.dns,runtimeRotationMinutes:global.wgControlServerSettings.runtimeRotationMinutes}),oe=()=>global.wgControlServerSettings.clientEncryptionPass,$=e=>{const t=q();return I(e)&&t.includes(String(e))},se=e=>$(e)?{success:!0,data:{...global.wgControlServerSettings.interfaces[String(e)]}}:{success:!1,errors:"Incorrect interface!"},ie=()=>global.wgControlServerSettings.endpoint,ae=e=>{global.wgControlServerSettings.wgIsWorking=e};export{q as getActiveInterfaceses,oe as getClientEncryptionPass,ie as getCurrentEndpoint,re as getDefaultInterface,ne as getFrontendConfig,se as getIfaceParams,$ as ifaceCorrect,te as loadServerConfig,ae as setWGStatus};
